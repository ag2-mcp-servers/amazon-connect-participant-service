# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T10:26:15+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class ArtifactId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ArtifactStatus(Enum):
    APPROVED = 'APPROVED'
    REJECTED = 'REJECTED'
    IN_PROGRESS = 'IN_PROGRESS'


class AttachmentIdList(RootModel[List[ArtifactId]]):
    root: List[ArtifactId] = Field(..., max_length=1, min_length=1)


class AttachmentName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class AttachmentSizeInBytes(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class Bool(RootModel[bool]):
    root: bool


class ChatContent(RootModel[constr(min_length=1, max_length=16384)]):
    root: constr(min_length=1, max_length=16384)


class ChatContentType(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class ChatItemId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ChatItemType(Enum):
    TYPING = 'TYPING'
    PARTICIPANT_JOINED = 'PARTICIPANT_JOINED'
    PARTICIPANT_LEFT = 'PARTICIPANT_LEFT'
    CHAT_ENDED = 'CHAT_ENDED'
    TRANSFER_SUCCEEDED = 'TRANSFER_SUCCEEDED'
    TRANSFER_FAILED = 'TRANSFER_FAILED'
    MESSAGE = 'MESSAGE'
    EVENT = 'EVENT'
    ATTACHMENT = 'ATTACHMENT'
    CONNECTION_ACK = 'CONNECTION_ACK'
    MESSAGE_DELIVERED = 'MESSAGE_DELIVERED'
    MESSAGE_READ = 'MESSAGE_READ'


class ClientToken(RootModel[constr(max_length=500)]):
    root: constr(max_length=500)


class CompleteAttachmentUploadResponse(BaseModel):
    pass


class ConflictException(RootModel[Any]):
    root: Any


class ConnectionType(Enum):
    WEBSOCKET = 'WEBSOCKET'
    CONNECTION_CREDENTIALS = 'CONNECTION_CREDENTIALS'


class ConnectionTypeList(RootModel[List[ConnectionType]]):
    root: List[ConnectionType] = Field(..., min_length=1)


class ContactId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ContentType(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class CreateParticipantConnectionRequest(BaseModel):
    ConnectParticipant: Optional[Bool] = None
    Type: Optional[ConnectionTypeList] = None


class DisconnectParticipantRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')


class DisconnectParticipantResponse(BaseModel):
    pass


class DisplayName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class GetAttachmentRequest(BaseModel):
    AttachmentId: ArtifactId


class ISO8601Datetime(RootModel[str]):
    root: str


class Instant(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class InternalServerException(RootModel[Any]):
    root: Any


class MaxResults(RootModel[conint(ge=0, le=100)]):
    root: conint(ge=0, le=100)


class MostRecent(RootModel[conint(ge=0, le=100)]):
    root: conint(ge=0, le=100)


class NextToken(RootModel[constr(min_length=1, max_length=1000)]):
    root: constr(min_length=1, max_length=1000)


class NonEmptyClientToken(RootModel[constr(min_length=1, max_length=500)]):
    root: constr(min_length=1, max_length=500)


class ParticipantId(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class ParticipantRole(Enum):
    AGENT = 'AGENT'
    CUSTOMER = 'CUSTOMER'
    SYSTEM = 'SYSTEM'


class ParticipantToken(RootModel[constr(min_length=1, max_length=1000)]):
    root: constr(min_length=1, max_length=1000)


class PreSignedAttachmentUrl(RootModel[constr(min_length=1, max_length=2000)]):
    root: constr(min_length=1, max_length=2000)


class PreSignedConnectionUrl(RootModel[constr(min_length=1, max_length=2000)]):
    root: constr(min_length=1, max_length=2000)


class Receipt(BaseModel):
    DeliveredTimestamp: Optional[Instant] = None
    ReadTimestamp: Optional[Instant] = None
    RecipientParticipantId: Optional[ParticipantId] = None


class Receipts(RootModel[List[Receipt]]):
    root: List[Receipt]


class ScanDirection(Enum):
    FORWARD = 'FORWARD'
    BACKWARD = 'BACKWARD'


class SendEventRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    Content: Optional[ChatContent] = None
    ContentType: ChatContentType


class SendEventResponse(BaseModel):
    AbsoluteTime: Optional[Instant] = None
    Id: Optional[ChatItemId] = None


class SendMessageRequest(BaseModel):
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    Content: ChatContent
    ContentType: ChatContentType


class SendMessageResponse(BaseModel):
    AbsoluteTime: Optional[Instant] = None
    Id: Optional[ChatItemId] = None


class ServiceQuotaExceededException(RootModel[Any]):
    root: Any


class SortKey(Enum):
    DESCENDING = 'DESCENDING'
    ASCENDING = 'ASCENDING'


class StartAttachmentUploadRequest(BaseModel):
    AttachmentName_1: AttachmentName = Field(..., alias='AttachmentName')
    AttachmentSizeInBytes_1: AttachmentSizeInBytes = Field(
        ..., alias='AttachmentSizeInBytes'
    )
    ClientToken: NonEmptyClientToken
    ContentType_1: ContentType = Field(..., alias='ContentType')


class StartPosition(BaseModel):
    AbsoluteTime: Optional[Instant] = None
    Id: Optional[ChatItemId] = None
    MostRecent_1: Optional[MostRecent] = Field(None, alias='MostRecent')


class ThrottlingException(RootModel[Any]):
    root: Any


class UploadMetadataSignedHeadersKey(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class UploadMetadataSignedHeadersValue(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class UploadMetadataUrl(RootModel[constr(min_length=1, max_length=2000)]):
    root: constr(min_length=1, max_length=2000)


class ValidationException(RootModel[Any]):
    root: Any


class Websocket(BaseModel):
    ConnectionExpiry: Optional[ISO8601Datetime] = None
    Url: Optional[PreSignedConnectionUrl] = None


class ParticipantAttachmentXAmzBearerPostRequest(BaseModel):
    AttachmentId: constr(min_length=1, max_length=256) = Field(
        ..., description='A unique identifier for the attachment.'
    )


class ParticipantCompleteAttachmentUploadXAmzBearerPostRequest(BaseModel):
    AttachmentIds: List[ArtifactId] = Field(
        ...,
        description='A list of unique identifiers for the attachments.',
        max_length=1,
        min_length=1,
    )
    ClientToken: constr(min_length=1, max_length=500) = Field(
        ...,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )


class ParticipantConnectionXAmzBearerPostRequest(BaseModel):
    ConnectParticipant: Optional[bool] = Field(
        None,
        description='Amazon Connect Participant is used to mark the participant as connected for customer participant in message streaming, as well as for agent or manager participant in non-streaming chats.',
    )
    Type: Optional[List[ConnectionType]] = Field(
        None,
        description='Type of connection information required. This can be omitted if <code>ConnectParticipant</code> is <code>true</code>.',
        min_length=1,
    )


class ParticipantDisconnectXAmzBearerPostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )


class ParticipantEventXAmzBearerPostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    Content: Optional[constr(min_length=1, max_length=16384)] = Field(
        None,
        description='<p>The content of the event to be sent (for example, message text). For content related to message receipts, this is supported in the form of a JSON string.</p> <p>Sample Content: "{\\"messageId\\":\\"11111111-aaaa-bbbb-cccc-EXAMPLE01234\\"}"</p>',
    )
    ContentType: constr(min_length=1, max_length=100) = Field(
        ...,
        description='<p>The content type of the request. Supported types are:</p> <ul> <li> <p>application/vnd.amazonaws.connect.event.typing</p> </li> <li> <p>application/vnd.amazonaws.connect.event.connection.acknowledged</p> </li> <li> <p>application/vnd.amazonaws.connect.event.message.delivered</p> </li> <li> <p>application/vnd.amazonaws.connect.event.message.read</p> </li> </ul>',
    )


class ParticipantMessageXAmzBearerPostRequest(BaseModel):
    ClientToken: Optional[constr(max_length=500)] = Field(
        None,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    Content: constr(min_length=1, max_length=16384) = Field(
        ...,
        description='<p>The content of the message. </p> <ul> <li> <p>For <code>text/plain</code> and <code>text/markdown</code>, the Length Constraints are Minimum of 1, Maximum of 1024. </p> </li> <li> <p>For <code>application/json</code>, the Length Constraints are Minimum of 1, Maximum of 12000. </p> </li> <li> <p>For <code>application/vnd.amazonaws.connect.message.interactive.response</code>, the Length Constraints are Minimum of 1, Maximum of 12288.</p> </li> </ul>',
    )
    ContentType: constr(min_length=1, max_length=100) = Field(
        ...,
        description='The type of the content. Supported types are <code>text/plain</code>, <code>text/markdown</code>, <code>application/json</code>, and <code>application/vnd.amazonaws.connect.message.interactive.response</code>.',
    )


class ParticipantStartAttachmentUploadXAmzBearerPostRequest(BaseModel):
    AttachmentName: constr(min_length=1, max_length=256) = Field(
        ..., description='A case-sensitive name of the attachment being uploaded.'
    )
    AttachmentSizeInBytes: conint(ge=1) = Field(
        ..., description='The size of the attachment in bytes.'
    )
    ClientToken: constr(min_length=1, max_length=500) = Field(
        ...,
        description='A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.',
    )
    ContentType: constr(min_length=1, max_length=255) = Field(
        ...,
        description='Describes the MIME file type of the attachment. For a list of supported file types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html">Feature specifications</a> in the <i>Amazon Connect Administrator Guide</i>.',
    )


class SortOrder(Enum):
    DESCENDING = 'DESCENDING'
    ASCENDING = 'ASCENDING'


class ParticipantTranscriptXAmzBearerPostRequest(BaseModel):
    ContactId: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description='The contactId from the current contact chain for which transcript is needed.',
    )
    MaxResults: Optional[conint(ge=0, le=100)] = Field(
        None,
        description='The maximum number of results to return in the page. Default: 10. ',
    )
    NextToken: Optional[constr(min_length=1, max_length=1000)] = Field(
        None,
        description='The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.',
    )
    ScanDirection_1: Optional[ScanDirection] = Field(
        None,
        alias='ScanDirection',
        description='The direction from StartPosition from which to retrieve message. Default: BACKWARD when no StartPosition is provided, FORWARD with StartPosition. ',
    )
    SortOrder_1: Optional[SortOrder] = Field(
        None,
        alias='SortOrder',
        description='The sort order for the records. Default: DESCENDING.',
    )
    StartPosition_1: Optional[StartPosition] = Field(
        None,
        alias='StartPosition',
        description='A filtering option for where to start. For example, if you sent 100 messages, start with message 50. ',
    )


class AttachmentItem(BaseModel):
    AttachmentId: Optional[ArtifactId] = None
    AttachmentName_1: Optional[AttachmentName] = Field(None, alias='AttachmentName')
    ContentType_1: Optional[ContentType] = Field(None, alias='ContentType')
    Status: Optional[ArtifactStatus] = None


class Attachments(RootModel[List[AttachmentItem]]):
    root: List[AttachmentItem]


class CompleteAttachmentUploadRequest(BaseModel):
    AttachmentIds: AttachmentIdList
    ClientToken: NonEmptyClientToken


class ConnectionCredentials(BaseModel):
    ConnectionToken: Optional[ParticipantToken] = None
    Expiry: Optional[ISO8601Datetime] = None


class CreateParticipantConnectionResponse(BaseModel):
    ConnectionCredentials_1: Optional[ConnectionCredentials] = Field(
        None, alias='ConnectionCredentials'
    )
    Websocket_1: Optional[Websocket] = Field(None, alias='Websocket')


class GetAttachmentResponse(BaseModel):
    Url: Optional[PreSignedAttachmentUrl] = None
    UrlExpiry: Optional[ISO8601Datetime] = None


class GetTranscriptRequest(BaseModel):
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')
    MaxResults_1: Optional[MaxResults] = Field(None, alias='MaxResults')
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ScanDirection_1: Optional[ScanDirection] = Field(None, alias='ScanDirection')
    SortOrder: Optional[SortKey] = None
    StartPosition_1: Optional[StartPosition] = Field(None, alias='StartPosition')


class MessageMetadata(BaseModel):
    MessageId: Optional[ChatItemId] = None
    Receipts_1: Optional[Receipts] = Field(None, alias='Receipts')


class UploadMetadataSignedHeaders(
    RootModel[Optional[Dict[str, UploadMetadataSignedHeadersValue]]]
):
    root: Optional[Dict[str, UploadMetadataSignedHeadersValue]] = None


class Item(BaseModel):
    AbsoluteTime: Optional[Instant] = None
    Attachments_1: Optional[Attachments] = Field(None, alias='Attachments')
    ContactId_1: Optional[ContactId] = Field(None, alias='ContactId')
    Content: Optional[ChatContent] = None
    ContentType: Optional[ChatContentType] = None
    DisplayName_1: Optional[DisplayName] = Field(None, alias='DisplayName')
    Id: Optional[ChatItemId] = None
    MessageMetadata_1: Optional[MessageMetadata] = Field(None, alias='MessageMetadata')
    ParticipantId_1: Optional[ParticipantId] = Field(None, alias='ParticipantId')
    ParticipantRole_1: Optional[ParticipantRole] = Field(None, alias='ParticipantRole')
    RelatedContactId: Optional[ContactId] = None
    Type: Optional[ChatItemType] = None


class Transcript(RootModel[List[Item]]):
    root: List[Item]


class UploadMetadata(BaseModel):
    HeadersToInclude: Optional[UploadMetadataSignedHeaders] = None
    Url: Optional[UploadMetadataUrl] = None
    UrlExpiry: Optional[ISO8601Datetime] = None


class GetTranscriptResponse(BaseModel):
    InitialContactId: Optional[ContactId] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    Transcript_1: Optional[Transcript] = Field(None, alias='Transcript')


class StartAttachmentUploadResponse(BaseModel):
    AttachmentId: Optional[ArtifactId] = None
    UploadMetadata_1: Optional[UploadMetadata] = Field(None, alias='UploadMetadata')
